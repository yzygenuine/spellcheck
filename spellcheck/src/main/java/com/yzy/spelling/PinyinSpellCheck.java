package com.yzy.spelling;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import net.sourceforge.pinyin4j.PinyinHelper;
import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;
import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;
import net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;
import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.yzy.analyzer.Analyzer;
import com.yzy.analyzer.PinYinAnalyser;
import com.yzy.spelling.index.Document;
import com.yzy.spelling.index.Index;

/**
 * @author yzy
 * 
 */
public class PinyinSpellCheck implements SpellCheck {
	/**
	 * 拼音格式化工具类
	 */
	private static HanyuPinyinOutputFormat outputFormat;
	/**
	 * 加载类后初始化
	 */
	static {
		outputFormat = new HanyuPinyinOutputFormat();
		outputFormat.setVCharType(HanyuPinyinVCharType.WITH_V);
		outputFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);
	}

	/**
	 * 索引管理类
	 */
	private final Index index = Index.getInstance();
	/**
	 * 日志记录引用
	 */
	private final Logger logger = LoggerFactory
			.getLogger(PinyinSpellCheck.class);
	// minimum score for hits generated by the spell checker query
	private float minScore = 0.0f;

	
	private String getPinyin(String word) {
		try {
			word = PinyinHelper.toHanyuPinyinString(word, outputFormat, "");
			return word;
		} catch (BadHanyuPinyinOutputFormatCombination e) {
			e.printStackTrace();
		}
		return "";
	}

	/**
	 * 编辑距离的类
	 */
	private StringDistance sd;

	private SuggestWordQueue _suggestSimilar(String word, int numSug) {
		if (sd == null) {
			sd = new NGramDistance();// 默认
		}
		float min = this.minScore;
		SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);
		List<Document> docList = index.getDocListByText(word, 1);
		word = getPinyin(word);
//		PinyinHelper.toHanYuPinyinString(word, outputFormat, word, false);
		if (docList == null || docList.size() <= 0) {
			return sugQueue;
		}
		logger.debug(word + "  找到相关的文档：" + docList.size());

		for (Document doc : docList) {
			SuggestWord sugWord = new SuggestWord();
			sugWord.string = doc.getText();
			System.out.println(sugWord.string);
			String py =  getPinyin(word);
			sugWord.score = sd.getDistance(word, py);
			if (sugWord.score < min) {
				continue;
			}
			sugWord.freq = doc.getFreq();
			sugWord.day = doc.getDay();
			sugQueue.insertWithOverflow(sugWord);
			if (sugQueue.size() == numSug) {
				min = sugQueue.top().score;
			}
		}
		return sugQueue;
	}

	

	/**
	 * 建议的词组
	 * 
	 * @param word
	 *            某个词
	 * @param numSug
	 *            建议的个数
	 * @return
	 */
	public String[] suggestSimilar(String word, int numSug) {
		SuggestWordQueue sugQueue = _suggestSimilar(word, numSug);
		String[] list = new String[sugQueue.size()];
		for (int i = sugQueue.size() - 1; i >= 0; i--) {
			list[i] = sugQueue.pop().string;
		}
		return list;
	}

	/**
	 * 建议的词组
	 * 
	 * @param word
	 *            某个词
	 * @param numSug
	 *            建议的个数
	 * @return
	 */
	public List<String> suggestSimilarList(String word, int numSug) {
		SuggestWordQueue sugQueue = _suggestSimilar(word, numSug);
		List<String> list = new ArrayList<String>(numSug);
		for (int i = sugQueue.size() - 1; i >= 0; i--) {
			list.add(sugQueue.pop().string);
		}
		return list;
	}

	/**
	 * 新接口，不作处理
	 * 
	 * @param word
	 * @param numSug
	 * @return
	 */
	public List<String> sugSimilar(String word, int numSug) {
		SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);
		List<Document> docList = index.getDocListByText(word, 1);
		logger.info(word + "  找到相关的文档：" + docList.size());
		if (docList == null || docList.size() <= 0) {
			return Collections.emptyList();
		}
	 
		for (int i=0;i< docList.size();i++) {
			Document doc=docList.get(i);
			SuggestWord sugWord = new SuggestWord();
//			logger.info(doc.getText()+":"+word);
			if (doc.getText().equals(word)) {
				return Collections.emptyList();
			}
			sugWord.string = doc.getText();
			sugWord.freq = doc.getFreq();
			sugWord.day = doc.getDay();
			sugWord.score=docList.size()-i;
			sugQueue.insertWithOverflow(sugWord);
		}
		List<String> list = new ArrayList<String>(numSug);
		for (int i = sugQueue.size() - 1; i >= 0; i--) {
			list.add(sugQueue.pop().string);
		}
		return list;
	}
	public float getMinScore() {
		return minScore;
	}

	public StringDistance getSd() {
		return sd;
	}

	public void setMinScore(float minScore) {
		this.minScore = minScore;
	}

	public void setSd(StringDistance sd) {
		this.sd = sd;
	}
}
