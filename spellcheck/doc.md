# 一、 索引管理

索引结构：ConcurrentHashMap 与CopyOnWriteArrayList相结合

 

## ConcurrentHashMap 

摒弃了单一的 map 范围的锁，取而代之的是由 32 个锁组成的集合，其中每个锁负责保护 hash bucket 的一个子集。锁主要由变化性操作（ put() 和 remove() ）使用。具有 32 个独立的锁意味着最多可以有 32 个线程可以同时修改 map。这并不一定是说在并发地对 map 进行写操作的线程数少于 32 时，另外的写操作不会被阻塞――32 对于写线程来说是理论上的并发限制数目，但是实际上可能达不到这个值。但是，32 依然比 1 要好得多，而且对于运行于目前这一代的计算机系统上的大多数应用程序来说已经足够了！

CopyOnWriteArrayList

 是ArrayList的一个线程安全的变体，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的。 

这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。“快照”风格的迭代器方法在创建迭代器时使用了对数组状态的引用。此数组在迭代器的生存期内绝不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。自创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。不支持迭代器上更改元素的操作（移除、设置和添加）。这些方法将抛出 UnsupportedOperationException。 

 

## 1. 索引创建

索引由无到有创建，在服务启动时运行，此时主要只有写，没有读，索引只有一份，中文拼写跟拼音检查共享一个索引，由一个单例模式的类管理。可以保证读取到的数据的唯一性，且索引由ConcurrentHashMap结构存储，可以允许多个写线程同时进行。

 

## 2. 索引更新

索引已存在，每天定时更新索引时，就会存在多读与写线程的存丰，此时，读的时候没有加锁，写的时候就会锁，但只是锁住ConcurrentHashMap中的某个片段，其它读写线程照样进行，提高更大的并发量。每一次更改某个key对应的CopyOnWriteArrayList时候，都会复制一个副本，所以旧数据并不会因为新增加数据而产生冲突。
